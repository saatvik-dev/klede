// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// shared/schema.ts
import { pgTable, text, serial, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull()
});
var insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true
});
var waitlistEntries = pgTable("waitlist_entries", {
  id: serial("id").primaryKey(),
  email: text("email").notNull().unique(),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var insertWaitlistSchema = createInsertSchema(waitlistEntries).pick({
  email: true
});
var emailSchema = z.object({
  email: z.string().email("Please enter a valid email address")
});

// server/db.ts
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
var poolConfig = {
  connectionString: process.env.DATABASE_URL
};
if (process.env.NODE_ENV === "production") {
  poolConfig.ssl = {
    rejectUnauthorized: false
    // Required for some providers like Heroku
  };
}
var pool = new pg.Pool(poolConfig);
var db = drizzle(pool);

// server/storage.ts
import { eq } from "drizzle-orm";
var DatabaseStorage = class {
  async getUser(id) {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user || void 0;
  }
  async getUserByUsername(username) {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user || void 0;
  }
  async createUser(insertUser) {
    const [user] = await db.insert(users).values(insertUser).returning();
    return user;
  }
  async getAllWaitlistEntries() {
    return await db.select().from(waitlistEntries).orderBy(waitlistEntries.createdAt);
  }
  async getWaitlistEntryByEmail(email) {
    const [entry] = await db.select().from(waitlistEntries).where(eq(waitlistEntries.email, email));
    return entry || void 0;
  }
  async addToWaitlist(entry) {
    const [waitlistEntry] = await db.insert(waitlistEntries).values(entry).returning();
    return waitlistEntry;
  }
  async deleteWaitlistEntry(id) {
    const [deleted] = await db.delete(waitlistEntries).where(eq(waitlistEntries.id, id)).returning();
    return !!deleted;
  }
};
var MemStorage = class {
  users;
  waitlist;
  currentUserId;
  currentWaitlistId;
  constructor() {
    this.users = /* @__PURE__ */ new Map();
    this.waitlist = /* @__PURE__ */ new Map();
    this.currentUserId = 1;
    this.currentWaitlistId = 1;
  }
  async getUser(id) {
    return this.users.get(id);
  }
  async getUserByUsername(username) {
    return Array.from(this.users.values()).find(
      (user) => user.username === username
    );
  }
  async createUser(insertUser) {
    const id = this.currentUserId++;
    const user = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }
  async getAllWaitlistEntries() {
    return Array.from(this.waitlist.values()).sort(
      (a, b) => a.createdAt.getTime() - b.createdAt.getTime()
    );
  }
  async getWaitlistEntryByEmail(email) {
    return Array.from(this.waitlist.values()).find(
      (entry) => entry.email === email
    );
  }
  async addToWaitlist(entry) {
    const id = this.currentWaitlistId++;
    const waitlistEntry = {
      ...entry,
      id,
      createdAt: /* @__PURE__ */ new Date()
    };
    this.waitlist.set(id, waitlistEntry);
    return waitlistEntry;
  }
  async deleteWaitlistEntry(id) {
    return this.waitlist.delete(id);
  }
};
var storage = process.env.DATABASE_URL ? new DatabaseStorage() : new MemStorage();

// server/routes.ts
import { ZodError } from "zod";
import { fromZodError } from "zod-validation-error";
import session from "express-session";
import MemoryStore from "memorystore";

// server/emails/emailService.ts
import nodemailer from "nodemailer";

// server/emails/templates.ts
function generateWelcomeEmail(email) {
  const subject = "Welcome to Our Exclusive Waitlist";
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Welcome to Our Waitlist</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    .logo {
      max-width: 150px;
      margin-bottom: 20px;
    }
    .content {
      background-color: #f9f9f9;
      padding: 30px;
      border-radius: 8px;
    }
    .footer {
      text-align: center;
      margin-top: 30px;
      font-size: 12px;
      color: #888;
    }
    h1 {
      color: #000;
      margin-top: 0;
    }
    p {
      margin-bottom: 20px;
    }
    .button {
      display: inline-block;
      background-color: #000;
      color: #fff;
      text-decoration: none;
      padding: 12px 25px;
      border-radius: 4px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <!-- Logo -->
      <img src="https://example.com/logo.png" alt="Logo" class="logo">
    </div>
    
    <div class="content">
      <h1>Thank You for Joining Our Waitlist</h1>
      
      <p>Hello,</p>
      
      <p>Thank you for joining our exclusive waitlist. We're thrilled to have you as part of our community.</p>
      
      <p>We're working hard to prepare our upcoming collection, and you'll be among the first to know when it launches.</p>
      
      <p>Stay tuned for exclusive updates and early access opportunities.</p>
      
      <p>Best regards,<br>The Team</p>
    </div>
    
    <div class="footer">
      <p>\xA9 2025 Company. All rights reserved.</p>
      <p>You're receiving this email because you signed up for our waitlist with this email address: ${email}</p>
    </div>
  </div>
</body>
</html>
  `;
  return { subject, html };
}
function generatePromotionalEmail(email, customMessage = "") {
  const subject = "Special Announcement for Our Waitlist Members";
  const promotionalMessage = customMessage || "We have some exciting news to share with you about our upcoming collection.";
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Special Announcement</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    .logo {
      max-width: 150px;
      margin-bottom: 20px;
    }
    .content {
      background-color: #f9f9f9;
      padding: 30px;
      border-radius: 8px;
    }
    .footer {
      text-align: center;
      margin-top: 30px;
      font-size: 12px;
      color: #888;
    }
    h1 {
      color: #000;
      margin-top: 0;
    }
    p {
      margin-bottom: 20px;
    }
    .button {
      display: inline-block;
      background-color: #000;
      color: #fff;
      text-decoration: none;
      padding: 12px 25px;
      border-radius: 4px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <!-- Logo -->
      <img src="https://example.com/logo.png" alt="Logo" class="logo">
    </div>
    
    <div class="content">
      <h1>Special Announcement</h1>
      
      <p>Hello,</p>
      
      <p>${promotionalMessage}</p>
      
      <p>As a valued member of our waitlist, you'll have exclusive early access before the general public.</p>
      
      <p>Stay tuned for more details coming soon.</p>
      
      <p>Best regards,<br>The Team</p>
    </div>
    
    <div class="footer">
      <p>\xA9 2025 Company. All rights reserved.</p>
      <p>You're receiving this email because you signed up for our waitlist with this email address: ${email}</p>
    </div>
  </div>
</body>
</html>
  `;
  return { subject, html };
}
function generateLaunchEmail(email) {
  const subject = "Our Collection Has Launched - Exclusive Access Inside";
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>We've Launched!</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      text-align: center;
      margin-bottom: 30px;
    }
    .logo {
      max-width: 150px;
      margin-bottom: 20px;
    }
    .content {
      background-color: #f9f9f9;
      padding: 30px;
      border-radius: 8px;
    }
    .footer {
      text-align: center;
      margin-top: 30px;
      font-size: 12px;
      color: #888;
    }
    h1 {
      color: #000;
      margin-top: 0;
    }
    p {
      margin-bottom: 20px;
    }
    .button {
      display: inline-block;
      background-color: #000;
      color: #fff;
      text-decoration: none;
      padding: 12px 25px;
      border-radius: 4px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <!-- Logo -->
      <img src="https://example.com/logo.png" alt="Logo" class="logo">
    </div>
    
    <div class="content">
      <h1>We've Launched!</h1>
      
      <p>Hello,</p>
      
      <p>We're excited to announce that our exclusive collection is now available!</p>
      
      <p>As a valued member of our waitlist, you now have exclusive early access before we open to the general public.</p>
      
      <p style="text-align: center;">
        <a href="https://example.com/collection" class="button">Shop the Collection Now</a>
      </p>
      
      <p>This exclusive access period will end in 48 hours, so be sure to explore the collection while you have priority access!</p>
      
      <p>Thank you for your interest and support.</p>
      
      <p>Best regards,<br>The Team</p>
    </div>
    
    <div class="footer">
      <p>\xA9 2025 Company. All rights reserved.</p>
      <p>You're receiving this email because you signed up for our waitlist with this email address: ${email}</p>
    </div>
  </div>
</body>
</html>
  `;
  return { subject, html };
}

// server/emails/emailService.ts
var EmailService = class {
  transporter;
  initialized = false;
  initializationPromise = null;
  constructor() {
    this.transporter = nodemailer.createTransport({
      host: process.env.EMAIL_HOST || "smtp.ethereal.email",
      port: parseInt(process.env.EMAIL_PORT || "587"),
      secure: process.env.EMAIL_SECURE === "true",
      auth: {
        user: process.env.EMAIL_USER || "",
        pass: process.env.EMAIL_PASS || ""
      }
    });
  }
  /**
   * Initialize the email service
   * If no email configuration is provided, it creates a test account using Ethereal
   */
  async initialize() {
    if (this.initialized) return;
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    this.initializationPromise = new Promise(async (resolve) => {
      if (!process.env.EMAIL_USER || !process.env.EMAIL_PASS) {
        try {
          console.log("[EmailService] No email credentials found, creating test account...");
          const testAccount = await nodemailer.createTestAccount();
          this.transporter = nodemailer.createTransport({
            host: "smtp.ethereal.email",
            port: 587,
            secure: false,
            auth: {
              user: testAccount.user,
              pass: testAccount.pass
            }
          });
          console.log("[EmailService] Test account created:");
          console.log(`- Username: ${testAccount.user}`);
          console.log(`- Password: ${testAccount.pass}`);
          console.log(`- Preview URL: https://ethereal.email/login`);
        } catch (error) {
          console.error("[EmailService] Error creating test account:", error);
        }
      }
      this.initialized = true;
      resolve();
    });
    return this.initializationPromise;
  }
  /**
   * Send an email
   * @param to Recipient email address
   * @param subject Email subject
   * @param html Email body in HTML format
   */
  async sendEmail(to, subject, html) {
    await this.initialize();
    const mailOptions = {
      from: process.env.EMAIL_FROM || "Waitlist <no-reply@example.com>",
      to,
      subject,
      html
    };
    try {
      const info = await this.transporter.sendMail(mailOptions);
      console.log("[EmailService] Email sent:", info.messageId);
      if (info.messageId && info.messageId.includes("ethereal")) {
        console.log("[EmailService] Preview URL:", nodemailer.getTestMessageUrl(info));
      }
      return info;
    } catch (error) {
      console.error("[EmailService] Error sending email:", error);
      throw error;
    }
  }
  /**
   * Send a welcome email to a new waitlist subscriber
   * @param email Recipient email address
   */
  async sendWelcomeEmail(email) {
    const { subject, html } = generateWelcomeEmail(email);
    return this.sendEmail(email, subject, html);
  }
  /**
   * Send a promotional email to a waitlist subscriber
   * @param email Recipient email address
   * @param customMessage Optional custom message to include in the email
   */
  async sendPromotionalEmail(email, customMessage) {
    const { subject, html } = generatePromotionalEmail(email, customMessage);
    return this.sendEmail(email, subject, html);
  }
  /**
   * Send a launch announcement email to a waitlist subscriber
   * @param email Recipient email address
   */
  async sendLaunchEmail(email) {
    const { subject, html } = generateLaunchEmail(email);
    return this.sendEmail(email, subject, html);
  }
};
var emailService = new EmailService();

// server/routes.ts
var SessionStore = MemoryStore(session);
var authenticateAdmin = (req, res, next) => {
  if (req.session.isAdmin) {
    next();
  } else {
    res.status(401).json({ message: "Unauthorized" });
  }
};
async function registerRoutes(app) {
  app.use(
    session({
      secret: process.env.SESSION_SECRET || "klede-secret-key",
      resave: false,
      saveUninitialized: false,
      cookie: {
        secure: process.env.NODE_ENV === "production",
        maxAge: 24 * 60 * 60 * 1e3
        // 24 hours
      },
      store: new SessionStore({
        checkPeriod: 864e5
        // prune expired entries every 24h
      })
    })
  );
  app.post("/api/waitlist", async (req, res) => {
    try {
      const validatedData = emailSchema.parse(req.body);
      const existingEntry = await storage.getWaitlistEntryByEmail(validatedData.email);
      if (existingEntry) {
        return res.status(409).json({
          message: "This email is already on the waitlist"
        });
      }
      const entry = await storage.addToWaitlist({
        email: validatedData.email
      });
      emailService.sendWelcomeEmail(validatedData.email).then(() => {
        console.log(`Welcome email sent to ${validatedData.email}`);
      }).catch((error) => {
        console.error(`Error sending welcome email to ${validatedData.email}:`, error);
      });
      res.status(201).json({
        message: "Successfully added to waitlist",
        entry
      });
    } catch (error) {
      if (error instanceof ZodError) {
        const validationError = fromZodError(error);
        res.status(400).json({ message: validationError.message });
      } else {
        console.error("Error adding to waitlist:", error);
        res.status(500).json({ message: "Failed to add to waitlist" });
      }
    }
  });
  app.post("/api/admin/login", (req, res) => {
    const { username, password } = req.body;
    if (username === "admin" && password === "admin") {
      req.session.isAdmin = true;
      res.json({ success: true });
    } else {
      res.status(401).json({ message: "Invalid credentials" });
    }
  });
  app.post("/api/admin/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ message: "Failed to logout" });
      }
      res.json({ success: true });
    });
  });
  app.get("/api/admin/waitlist", authenticateAdmin, async (_req, res) => {
    try {
      const entries = await storage.getAllWaitlistEntries();
      res.json(entries);
    } catch (error) {
      console.error("Error retrieving waitlist entries:", error);
      res.status(500).json({ message: "Failed to retrieve waitlist entries" });
    }
  });
  app.delete("/api/admin/waitlist/:id", authenticateAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID format" });
      }
      const success = await storage.deleteWaitlistEntry(id);
      if (!success) {
        return res.status(404).json({ message: "Entry not found" });
      }
      res.json({ success: true });
    } catch (error) {
      console.error("Error deleting waitlist entry:", error);
      res.status(500).json({ message: "Failed to delete waitlist entry" });
    }
  });
  app.get("/api/admin/check", (req, res) => {
    res.json({ isAuthenticated: req.session.isAdmin === true });
  });
  app.post("/api/admin/send-promotional", authenticateAdmin, async (req, res) => {
    try {
      const { message } = req.body;
      const entries = await storage.getAllWaitlistEntries();
      if (entries.length === 0) {
        return res.status(404).json({ message: "No waitlist entries found" });
      }
      const emailPromises = entries.map(
        (entry) => emailService.sendPromotionalEmail(entry.email, message).catch((error) => {
          console.error(`Error sending promotional email to ${entry.email}:`, error);
          return { error: true, email: entry.email };
        })
      );
      const results = await Promise.all(emailPromises);
      const failedEmails = results.filter((result) => result && result.error).map((result) => result.email);
      const successCount = entries.length - failedEmails.length;
      res.json({
        message: `Promotional emails sent to ${successCount} of ${entries.length} subscribers`,
        failedEmails: failedEmails.length > 0 ? failedEmails : void 0
      });
    } catch (error) {
      console.error("Error sending promotional emails:", error);
      res.status(500).json({ message: "Failed to send promotional emails" });
    }
  });
  app.post("/api/admin/send-launch-announcement", authenticateAdmin, async (req, res) => {
    try {
      const entries = await storage.getAllWaitlistEntries();
      if (entries.length === 0) {
        return res.status(404).json({ message: "No waitlist entries found" });
      }
      const emailPromises = entries.map(
        (entry) => emailService.sendLaunchEmail(entry.email).catch((error) => {
          console.error(`Error sending launch email to ${entry.email}:`, error);
          return { error: true, email: entry.email };
        })
      );
      const results = await Promise.all(emailPromises);
      const failedEmails = results.filter((result) => result && result.error).map((result) => result.email);
      const successCount = entries.length - failedEmails.length;
      res.json({
        message: `Launch announcement emails sent to ${successCount} of ${entries.length} subscribers`,
        failedEmails: failedEmails.length > 0 ? failedEmails : void 0
      });
    } catch (error) {
      console.error("Error sending launch announcement emails:", error);
      res.status(500).json({ message: "Failed to send launch announcement emails" });
    }
  });
  if (process.env.VERCEL) {
    return null;
  }
  const httpServer = createServer(app);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2, { dirname as dirname2 } from "path";
import { fileURLToPath as fileURLToPath2 } from "url";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import themePlugin from "@replit/vite-plugin-shadcn-theme-json";
import path, { dirname } from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
import { fileURLToPath } from "url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname(__filename);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    themePlugin(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client", "src"),
      "@shared": path.resolve(__dirname, "shared"),
      "@assets": path.resolve(__dirname, "attached_assets")
    }
  },
  root: path.resolve(__dirname, "client"),
  build: {
    outDir: path.resolve(__dirname, "dist/public"),
    emptyOutDir: true
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var __filename2 = fileURLToPath2(import.meta.url);
var __dirname2 = dirname2(__filename2);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        __dirname2,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app) {
  const distPath = path2.resolve(__dirname2, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app.use(express.static(distPath));
  app.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
function createExpressApp() {
  const app = express2();
  app.use(express2.json());
  app.use(express2.urlencoded({ extended: false }));
  app.use((req, res, next) => {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
    if (req.method === "OPTIONS") {
      return res.status(200).end();
    }
    next();
  });
  app.use((req, res, next) => {
    const start = Date.now();
    const path3 = req.path;
    let capturedJsonResponse = void 0;
    const originalResJson = res.json;
    res.json = function(bodyJson, ...args) {
      capturedJsonResponse = bodyJson;
      return originalResJson.apply(res, [bodyJson, ...args]);
    };
    res.on("finish", () => {
      const duration = Date.now() - start;
      if (path3.startsWith("/api")) {
        let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
        if (capturedJsonResponse) {
          logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
        }
        if (logLine.length > 80) {
          logLine = logLine.slice(0, 79) + "\u2026";
        }
        log(logLine);
      }
    });
    next();
  });
  return app;
}
async function createServer2(options = { serverless: false }) {
  const app = createExpressApp();
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    console.error(err);
  });
  if (options.serverless) {
    serveStatic(app);
  } else {
    if (process.env.NODE_ENV !== "production") {
      if (server) {
        await setupVite(app, server);
      } else {
        serveStatic(app);
      }
    } else {
      serveStatic(app);
    }
  }
  return { app, server };
}
if (process.env.TS_NODE_DEV === "true" || process.argv[1]?.endsWith("server/index.ts")) {
  (async () => {
    const { app, server } = await createServer2();
    if (server) {
      const port = process.env.PORT || 5e3;
      server.listen({
        port,
        host: "0.0.0.0",
        reusePort: true
      }, () => {
        log(`serving on port ${port}`);
      });
    } else {
      log(`Server not created - possibly running in serverless mode`);
    }
  })();
}
var defaultApp = createExpressApp();
var index_default = defaultApp;
export {
  createServer2 as createServer,
  index_default as default
};